# week3

# 깊이/너비 우선 탐색(DFS/BFS)

<img width="1146" alt="스크린샷 2022-03-17 오후 11 01 15" src="https://user-images.githubusercontent.com/68533016/158830661-01d8996b-fbca-4eb7-a588-afcde65cda43.png">

| -             | DFS                                                          | BFS                                                                                                  |
| ------------- | ------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------- |
| 개념          | 최대한 깊이 내려감                                           | 최대한 옆으로 이동함                                                                                 |
|               | 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식 | 시작 정점으로부터 가장 가까운 정점을 먼제 방문하고 가장 멀리 떨어져 있는 정점을 나중에 방문하는 방법 |
| 사용하는 경우 | 모든 노드를 방문할 때                                        | 두 노드 사이의 최단 경로를 찾고 싶을 때                                                              |
| 구현          | 재귀 or 스택                                                 | 큐                                                                                                   |
| 시간 복잡도   | 인접 리스트 : O(N+E) , 인접 행렬 : O(V^2)                    | 인접 리스트 : O(N+E) , 인접 행렬 : O(V^2)                                                            |
| 속도          | BFS에 비해 느림 (찾는 노드의 depth가 깊을 수록 빠름)         | DFS에 비해 빠름                                                                                      |
| 메모리        | 소모 적음                                                    | 소모 큼                                                                                              |

## 활용 문제

1. 그래프의 `모든 정점을 방문`하는 것이 중요한 문제

- `DFS, BFS`는 모든 정점을 방문하는 `완전탐색`의 일종이므로 아무거나 써도 됨

2. `경로의 특징`을 저장해둬야 하는 문제

- 전략 게임에서 하나의 수에 잇따른 가능성들을 파고 드는 문제 등
- `DFS` 를 사용
- `BFS`는 경로의 특징을 가지지 못함

3. `최단 거리`를 구해야 하는 문제

- `BFS` 를 사용
  - 미로찾기 등
  - 가중치가 없어야 함
- why?

  - `DFS 깊이 우선 탐색` 을 사용하는 경우 정점 간의 경로는 찾을 수 있지만, 최단 거리가 아닐 가능성이 있음
  - `BFS 너비 우선 탐색` 은 현재 노드로부터 가까운 노드부터 탐색하기 때문에 경로(답)을 발견하면 최단 거리임

- 최단 경로 알고리즘
  - `다익스트라 알고리즘`
    - 간선에 가중치가 다를 때
    - 가중치에 음수가 없어야 함
    - 우선순위 큐
  - `플로이드 워셜 알고리즘`
    - `다익스트라 알고리즘` 은 **하나**의 정점에서 출발했을 때 다른 모든 정점으로의 최단 경로를 구함
    - **모든 정점**에서 모든 정점으로의 최단 경로를 구할 때

4.

- 트리의 깊이마다 노드들이 많고 트리가 넓다면 `메모리 소모`가 크기 때문에 `BFS`보다 `DFS`를 사용

- 깊이의 끝이 없거나 아주 깊이 들어가는 경우 `DFS` 사용 자제

  - why?
    - 탈출 불가

- 검색 대상 그래프가 정말 크다면 `DFS` 를 고려

  - ❗️ `그래프가 정말 크다면....??` 이 어느 정도일지 모르겠다

- 검색 대상의 규모가 크지 않고, 검색 시작 지점으로부터 원하는 대상이 별로 멀지 않다면 `BFS`
  - ❗️ 마찬가지로 `검색 대상의 규모` 가 감이 안 온다

## 백트래킹 (Backtraking)

- `완전탐색` 여러 개의 solution 을 가진 문제에서 모든 solution을 탐색하는 전략
- DFS 문제에서 제한이 있는 경우 `백트래킹`으로 case를 줄일 수 있음
- 구현

  - 재귀 or 스택을 사용한 `DFS`

- 원리
  - 어떤 노드의 유망성을 점검 후
    - 유망하지 않으면 배제 (더 이상 가지 않음)
    - 해당 노드의 부모노드로 되돌아간 후 다른 자손 노드 탐색
  - 가지치기(pruning)으로 시간 효율을 높임

### DFS vs 백트래킹

- `DFS` : 반드시 모든 노드를 거침
- `백트래킹` : 가능성이 있는 노드만 거침
  - pruning

### 참고

- https://devuna.tistory.com/32
- https://velog.io/@leobit/DFS-BFS-%EB%B0%B1%ED%8A%B8%EB%9E%98%ED%82%B9Backtracking
