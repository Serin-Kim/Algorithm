## 해시의 등장 배경

배열은 내부 인덱스를 이용하여 자료의 검색이 한 번에 이루어지기 때문에 빠른 검색 속도를 보이는 반면, 데이터의 삽입, 삭제 시 많은 데이터가 밀리거나 빈 자리를 채우기 위해 이동해야 하므로 많은 시간이 소요된다.

반면 연결 리스트는 삽입, 삭제 시 인근 노드들의 참조 값만 수정해 주면서 빠른 처리가 가능하다. 하지만 처음과 마지막 노드 이외의 위치에서 데이터를 삽입, 삭제하거나 검색할 경우 해당 노드를 찾기 위해 처음부터 순회 검색을 해야하기 때문에 데이터의 수가 많아질수록 효율이 떨어질 수 밖에 없는 구조다.

이러한 한계를 극복하기 위해 제시된 방법이 바로 해시(Hash)다.

## 해시(Hash)

해시는 데이터를 다루는 기법 중 하나로 검색과 저장을 아주 빠르게 해주는 `자료구조`이다

임의의 크기를 가진 데이터(key)를 고정된 크기의 데이터(value)로 변환시켜 저장한다.

키에 대한 해시 값을 사용하여 값을 저장하고, 키-값 쌍의 개수에 따라 동적으로 크기가 증가하는 연관 배열 구조(associative array)이다

연관 배열 구조란 key와 value가 1:1로 연관되어 있는 자료구조이고 key를 통해 value를 알아낼 수 있다

배열의 인덱스와 다르게 순차적으로 저장되는 것이 아닌, 전 영역에 고르게 분포되어 저장되기 때문에 삽입이나 삭제 시 다른 데이터로 자리를 채울 필요가 없어 데이터의 이동이 없다 (배열보다 빠르게 값을 찾을 수 있다)

![https://media.vlpt.us/images/xxhaileypark/post/dfd306f8-38a6-4e92-ba66-45ef56c3c791/Screen%20Shot%202022-02-21%20at%204.03.04%20PM.png](https://media.vlpt.us/images/xxhaileypark/post/dfd306f8-38a6-4e92-ba66-45ef56c3c791/Screen%20Shot%202022-02-21%20at%204.03.04%20PM.png)

### key

- 해시에서 매핑할 때 사용하는 인덱스
- 절대 중복되지 않는 특성을 가진다(고유한 값)
- 해시 함수의 input이 된다
- 키 값 그대로 저장소에 저장할 경우 다양한 키의 길이만큼 크기를 구성해두어야 하기 때문에 일정한 길이의 해시로 변경현다(해시 코드)

### value

- key로 매핑 시 나오는 output
- 저장소(bucket, slot)에 최종적으로 저장되는 값으로 해시와 매칭되어 저장

## 해시 함수(Hash function)

데이터의 효율적 관리를 목적으로 임의 길이의 데이터를 입력받아 일정한 길이의 비트열로 반환시켜주는 함수 (이 변환 과정을 해싱이라고 함)

계산이 복잡하지 않고 key에 대해 중복없이 해시값을 고르게 만들어 내는 함수가 좋은 함수이다 (= 충돌이 일어나지 않을수록 좋다)

여기서 충돌(hash collision)이란 해시 함수를 통하여 해싱한 해시값이 중복인 경우를 말한다

```jsx
function hashFunction(key) {
  return key % 10;
}

console.log(hashFunction(102948)); // 8
console.log(hashFunction(191919191)); // 1
console.log(hashFunction(13)); // 3
console.log(hashFunction(997)); // 7
```

어떤 값이 들어오든 그 값의 1의 자리를 반환하여 0~9 사이의 값이라는 게 보장 된 간단한 해시 함수

## 해시 테이블(Hash Table)

해시 테이블은 해시 함수를 통해 key를 해시 값으로 매핑하고, 이 해시 값을 색인(index)혹은 주소로 삼아 데이터의 값(value)을 키와 함께 저장하는, 연관 배열 구조를 이용하는 자료구조이다

버킷(bucket)과 슬롯(slot)이라는 저장소를 가지고 있다

해시 테이블의 기본 연산으로는 삽입(insertion), 삭제(deletion), 탐색(search)가 있고 모두 평균적으로 O(1)의 시간 복잡도를 가진다

```jsx
const myTableSize = 5;
const myHashTable = new Array(myTableSize);

function hashFunction(key) {
  return key % myTableSize;
}

myHashTable[hashFunction(1991)] = 1991;
myHashTable[hashFunction(1234)] = 1234;
myHashTable[hashFunction(5678)] = 5678;

console.log(myHashTable); // [empty, 1991, empty, 5678, 1234]
```

테이블의 크기를 5로 제한하고 그 크기로 나눈 나머지 값을 반환하여 어떠한 수가 들어오더라도 해시 테이블 안에 넣을 수 있다 이렇게 하면 직접 주소 테이블(key와 value가 같은 배열)의 단점인 낭비되는 공간을 줄일 수 있게 된다

## 해시 충돌(Hash Collision)

서로 다른 key 값을 해시 함수를 통해 해싱한 값이 중복인 경우를 해시 충돌이라고 한다

무한한 값(해시 테이블에서의 key)을 유한한 값(해시 테이블에서의 hash)으로 표현한다면 서로 다른 두 개 이상의 유한한 값이 동일한 출력값을 가지게 될 수 밖에 없기 때문에 필연적인 현상이다 (비둘기 집 원리)

위 함수에서 예를 들면 공간이 5로 유한하기 때문에 5로 나눈 나머지가 같은 숫자일 경우 해시 충돌이 발생한다

```jsx
hashFunction(1991); // 1
hashFunction(6); // 1
```

## 해시 충돌의 해결

해시 테이블에는 해시 충돌이라는 단점이 있기 때문에 가장 중요한 점이 해시 함수가 얼마나 균일하게 값을 퍼트릴 수 있느냐이다. 어떤 값을 넣어도 같은 인덱스만 주구장창 나올 확률이 높다면 좋은 해시 함수가 아닌 것이다.

하지만 해시 함수를 아무리 잘 짜더라도 근본적으로 충돌을 완전히 방지한다는 것은 사실상 불가능하다. 그렇기 때문에 어느 정도는 충돌을 감안하고 최소화하기 위해 해시 함수의 알고리즘을 개발하거나, 혹은 충돌이 발생하더라도 우회해서 해결할 수 있는 방법을 사용한다

### 개방 주소법(Open Address)

개방 주소법은 해시 충돌이 발생하면 테이블 내의 새로운 주소를 탐사(probe) 후, 비어있는 곳에 충돌된 데이터를 입력하는 방식이다. 해시 함수를 통해서 얻은 인덱스가 아니라 다른 인덱스를 허용한다는 의미로 개방 주소라고 한다

개방 주소법은 어떤 방식으로 비어있는 공간을 탐사할 것이냐에 따라 몇 가지로 나누어 진다

### 1. 선형 탐사법(Linear Probing)

![https://www.educative.io/api/page/4910944193871872/image/download/5691071517425664](https://www.educative.io/api/page/4910944193871872/image/download/5691071517425664)

선형 탐사법은 충돌이 났을 경우 정해진 n칸 만큼 뒤의 인덱스를 할당하는 방식이다. 만약 그 자리에서도 충돌이 났다면 다시 n칸 만큼 뒤로 밀리게 된다. 이런 방식으로 빈 공간이 나타날 때 까지 순차적으로 탐사를 진행한다.

선형 탐사법의 단점은 n값을 현명하게 설정하지 않는다면 수 많은 공간들을 그냥 뛰어넘어 비어있는 공간들을 허비하게 될 수 있다는 점이다.

또한 선형 탐사법을 사용하면 데이터가 연속되게 저장될 가능성이 높아지는데 데이터의 밀집도가 높아져 악순환이 반복될 수 있다.(일차 군집화)

### 2. 제곱 탐사법(Quadratic Probing)

제곱 탐사법은 선형 탐사법과 동일하지만 탐사하는 폭이 고정폭이 아닌 제곱으로 늘어난다는 점이 다르다.

첫 번재 충돌이 발생했을 때는 충돌난 지점으로부터 1^2만큼, 두 번째 충돌에서는 2^2만큼, 세 번째는 3^2만큼 같은 식으로 탐사하는 폭이 빠르게 커진다. 이렇게 되면 충돌이 발생하더라도 데이터의 밀집도가 선형 탐사법보다 많이 낮아지기 때문에 다른 해시값까지 영향을 받아서 연쇄적으로 충돌이 발생할 확률이 많이 줄어든다

그래도 결국 해시로 1이 여러번 나오게 되면 계속 충돌이 나는 것은 피할 수 없다. (이차 군집화)

### 3. 이중 해싱(Double Hashing)

그래서 나온 방법이 바로 이중 해싱이다. 말 그대로 해시 함수를 이중으로 사용하는 것이다.

하나는 기존과 마찬가지로 최초 해시를 얻을 때 사용하고, 다른 하나는 충돌이 났을 경우 탐사 이동 폭(offset value)을 얻기 위해 사용한다. 이렇게 하면 최초 해시로 같은 값이 나오더라도 다시 다른 해시 함수를 거치면서 다른 탐사 이동 폭이 나올 확률이 높기 때문에 매번 다른 공간에 값이 골고루 저장될 확률도 높아진다.

```jsx
(firstHash(key) + i * secondHash(key)) % tableSize;
```

### 분리 연결법(Separate Chaining)

![https://www.educative.io/api/page/4910944193871872/image/download/4810203387133952](https://www.educative.io/api/page/4910944193871872/image/download/4810203387133952)

분리 연결법은 해쉬 테이블의 버킷에 하나의 값이 아니라, 연결 리스트(Linked List)나 트리(Red-Black Tree)를 사용한다. 두 개의 기준은 data가 6개 이하이면 연결 리스트를, 8개 이상이면 트리를 사용한다. 만약 7개일 때 데이터를 삭제하게되면 연결 리스트로 바꿔야 하고, 추가되면 트리로 바꿔야 한다. 이 때 바꾸면서 오버헤드가 발생하여 기준이 6과 8이 되는 것이다.(잘 모르겠음)

버킷 내에 연결 리스트를 할당하여, 버킷에 데이터를 삽입하다가 해시 충돌이 발생하면 해당 값을 기존 값과 연결시킨다.

분리 연결법에서는 해시 함수의 역할이 굉장히 중요하다. 균일하지 못한 해시를 사용해서 특정 인덱스에 데이터가 몰리게 된다면 다른 곳은 텅텅 비어있는데 한 버킷에 저장된 리스트의 길이만 계속 길어지기 때문이다.

결국 찾고자 하는 값이 리스트의 맨 마지막에 위치하고 있다면 연결 리스트를 처음부터 끝까지 다 탐색해야하기 때문에 O(n)의 시간 복잡도를 가지게 된다. 그렇기 때문에 최대한 저장하고자 하는 데이터를 균일하게 퍼트려서 리스트의 길이를 어느 정도로 유지해주는 해시 함수의 역할이 중요한 것이다.

한정한 저장소를 효율적으로 사용할 수 있지만, 추가로 외부 저장 공간을 필요로 한다.

### 테이블 크기 재할당(Resizing)

해시 테이블은 고정적인 공간을 할당하여 많은 데이터를 담기 위한 자료구조인 만큼 언젠가 데이터가 넘치게 되기 마련이다.

개방 주소법의 경우 고정 크기 배열을 사용하기 때문에 데이터를 더 넣기 위해서는 배열을 확장해줘야하고, 분리 연결법의 경우 버킷이 일정 수준으로 차 버리면 각 버킷에 연결되어 있는 리스트의 길이가 늘어나기 때문에 검색 성능이 떨어지게 되므로 버킷의 개수를 늘려줘야 한다.

해시 테이블은 꽉곽 채워지기보다는 어느 정도 비워져 있는 것이 성능 상 좋기 때문에 어느 정도 데이터가 차면 테이블의 크기를 늘려줘야하는데 이 작업을 리사이징이라고 한다.

보통 두 배로 확장하는데, 확장하는 임계점은 현재 데이터 개수가 해시 버킷의 개수의 75%가 될 때이다. 0.75라는 숫자는 load factor라고 불린다. 리사이징은 더 큰 버킷을 가지는 배열을 새로 만든 다음, 기존 배열의 해시를 다시 계산해서 복사해준다.

## 해시 테이블 데이터 구조의 단점

- 순서가 있는 배열에는 어울리지 않는다
  :순서와 상관없이 key만 가지고 hash를 찾아 저장하기 때문이다
- 공간 효율성이 떨어진다
  : 데이터가 저장되기 전에 미리 저장 공간을 확보해야 한다. 공간이 부족하거나 아예 채워지지 않은 경우가 생길 가능성이 있다
- 해시 함수의 의존도가 높다
  : 평균 데이터 처리의 시간 복잡도는 O(1)이지만, 이는 해시 함수의 연산을 고려하지 않은 결과이다. 해시 함수가 매우 복잡하다면서 해시 테이블의 모든 연산의 시간 효율성은 증가할 것이다

## Reference

[https://evan-moon.github.io/2019/06/25/hashtable-with-js/](https://evan-moon.github.io/2019/06/25/hashtable-with-js/)

[https://www.educative.io/blog/data-strucutres-hash-table-javascript](https://www.educative.io/blog/data-strucutres-hash-table-javascript)

[https://velog.io/@hanif/자료구조-해시](https://velog.io/@hanif/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%95%B4%EC%8B%9C)

[https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table해시-해싱-해시테이블-자료구조의-이해-6ijyonph6o](https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table%ED%95%B4%EC%8B%9C-%ED%95%B4%EC%8B%B1-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%9D%B4%ED%95%B4-6ijyonph6o)
