# 완전탐색 (Exhausitive Search)

- 가능한 모든 경우의 수를 탐색하고 확인하는 방법
- Brute Force 또는 Generate & Test 라고 불리기도 한다.
- 일반적으로 탐색해야 할 데이터의 개수가 100만개 이하일 때 사용하면 적절하다.

  즉, **검색해봐야 할 모든 경우의 수가 적을 때** 적절하다.

- 직관적이므로 이해하기 쉽고 문제의 정확한 결과값을 얻어낼 수 있는 가장 확실하며 기초적인 방법이지만, 문제를 파악 후 완전 탐색을 적용할 수 있을지, 적용한다면 효율적으로 동작할 수 있을지 생각해보아야 한다.
- 또한 완전 탐색을 적용할 경우 시간 제한을 잘 체크해야 한다.   
<br />

### 완전 탐색을 고려해볼만한 경우

- 입력으로 주어지는 데이터의 크기가 작다.
- 답의 범위가 작고, 임의의 답을 하나 선택했을 때 문제 조건을 만족하는지 역추적할 수 있다.
- 여러 문제 조건 중 한 조건을 고정시키면 문제 풀이가 간단해진다.   
<br />

## 완전 탐색 기법 종류

- Brute Force
- 비트 마스크
- 재귀
- 순열
- BFS / DFS   
<br />

### Brute Force

- 단순히 `for` 문과 `if` 문 등으로 모든 케이스를 탐색하며 답을 구하는 방법
- 기초적인 문제에서 주로 이용되거나 전체 풀이의 일부분으로 이용한다.  
<br />

### 비트 마스크 (Bitmask)

- 2진수를 이용하는 컴퓨터의 연산을 이용하는 방법
- 문제에서 나올 수 있는 모든 경우의 수가 각각의 원소가 **포함되거나 포함되지 않는 두 가지 선택으로 구성**되는 경우에 유용하다.
- 비트 연산의 시간 복잡도는 내부적으로 상수 시간 정도로 처리되어 O(1)이라고 보면 된다.   
<br />

**비트 연산**

- AND `&` : 두 비트가 모두 1이면 1
- OR `|` : 두 비트 중 하나라도 1이면 1
- NOT `~` : 단항 연산자, 피연산자의 모든 비트를 반전시킨다. (ex. 1 ⇒ 0, 0 ⇒ 1)
- XOR `^` : 두 비트의 값이 같으면 0, 다르면 1
- SHIFT `<<` `>>` : 지정된 개수만큼 모든 비트를 이동시킨다. 우측으로 이동시킬 때 밀리는 것들은 그냥 삭제된다.
    - 7 << 3 : 111 ⇒ 111000
    - 10 >> 2 : 1010 ⇒ 10   
<br />

**비트 연산 활용**

```
S = { 1, 3, 5, 7, 9 }
s = { 1, 5, 7 }
```
<br />

1. 비트 연산으로 집합 나타내기

ex. 원소가 5개인 집합의 모든 부분집합을 구하는 경우 5자리 2진수를 이용해 각 원소의 포함 여부를 체크할 수 있다.


| 0 | 1 | 3 | 5 | 7 | 9 | { 1, 3, 5, 7, 9 } |
| --- | --- | --- | --- | --- | --- | --- |
| 1 | 0 | 0 | 0 | 0 | 0 | { } |
| 2 | 0 | 0 | 0 | 0 | 1 | { 9 } |
| 5 | 0 | 0 | 0 | 1 | 0 | { 7 } |
| 14 | 0 | 0 | 1 | 0 | 1 | { 5, 9 } |
| 31 | 1 | 1 | 1 | 1 | 1 | { 1, 3, 5, 7, 9 } |
<br />

2. 집합 포함 여부 확인하기

포함 여부를 확인하고 싶은 숫자가 있는 곳의 비트를 1로, 나머지는 0으로 한 것과 집합을 **AND 연산**하여 확인할 수 있다.

ex. s 집합에 1이 존재하는가?

|  | 1 | 3 | 5 | 7 | 9 |
| --- | --- | --- | --- | --- | --- |
| s | 1 | 0 | 1 | 1 | 0 |
| 1 | 1 | 0 | 0 | 0 | 0 |
| AND | 1 | 0 | 0 | 0 | 0 |

AND 연산을 수행했을 때 1이 있는 곳의 비트가 1이므로 집합에 1이 존재한다는 것을 알 수 있다.   
<br />

3. 숫자 추가하기

집합에 추가하고 싶은 숫자가 있는 곳의 비트를 1로, 나머지는 0으로 한 것과 집합을 **OR 연산**하여 추가할 수 있다.

   ex. s 집합에 9 추가하기

|  | 1 | 3 | 5 | 7 | 9 |
| --- | --- | --- | --- | --- | --- |
| s | 1 | 0 | 1 | 1 | 0 |
| 1 | 0 | 0 | 0 | 0 | 1 |
| OR | 1 | 0 | 1 | 1 | 1 |
<br />

4. 특정 숫자 제거하기

**NOT 연산**을 사용해 제거하고 싶은 숫자가 있는 곳의 비트만 0으로, 나머지는 1로 만든 것과 집합을 **AND 연산**하면 해당 숫자를 제거할 수 있다.

ex. s 집합에서 5 제거하기

|  | 1 | 3 | 5 | 7 | 9 |
| --- | --- | --- | --- | --- | --- |
| s | 1 | 0 | 1 | 1 | 0 |
| NOT 5 | 1 | 1 | 0 | 1 | 1 |
| AND | 1 | 0 | 0 | 1 | 0 |
<br />

5. 토글 연산하기

비트가 1이면 0으로, 0이면 1로 바꾸고 싶다면 바꾸고 싶은 숫자가 있는 곳의 비트를 1로, 나머지는 0인 것과 집합을 **XOR 연산**하면 된다.

ex. s 집합에서 3 토글하기

|  | 1 | 3 | 5 | 7 | 9 |
| --- | --- | --- | --- | --- | --- |
| s | 1 | 0 | 1 | 1 | 0 |
| 3 | 0 | 1 | 0 | 0 | 0 |
| XOR | 1 | 1 | 1 | 1 | 0 |

ex. s 집합에서 7 토글하기

|  | 1 | 3 | 5 | 7 | 9 |
| --- | --- | --- | --- | --- | --- |
| s | 1 | 0 | 1 | 1 | 0 |
| 3 | 0 | 0 | 0 | 1 | 0 |
| XOR | 1 | 0 | 1 | 0 | 0 |
<br />

### 재귀

- 자기 자신을 호출하는 재귀 함수를 이용하는 방법
- 매 단계마다 함수는 원본 문제보다 좀 더 작고 단순한 문제를 가지고 자기 자신을 호출해 해결하게 함으로써 문제를 해결한다.
- 재귀를 사용하면 코드가 짧아지고 코드 이해도가 높아지며 유지보수에도 이점이 있다.
- 재귀를 사용해 작성한 코드는 반복문을 사용한 코드로 다시 작성할 수 있으며, 반복문을 사용할 경우 대개 함수 호출 비용(메모리 사용)이 절약된다.
- 비트마스크와 같이 주로 각 원소가 포함되거나 포함되지 않는 두 가지 선택을 가질 때 이용된다.
- **반복적인 호출에서 탈출할 수 있는 조건을 반드시 명시해주어야 한다.**
- **현재 함수의 상태를 저장하는 파라미터가 필요하다.**

ex. 1부터 주어진 숫자까지의 합을 구하는 함수 작성하기

```jsx
function sumTo(n) {
  if (n === 1) return n;
  return n + sumTo(n - 1);
}

sumTo(10);
```
<br />

### 순열
<br />

**순열**

- 서로 다른 n개 중 r개를 선택하는 경우의 수
- 순서와 상관이 있으며 중복은 허용되지 않는다.

**예시**

과자 4종류와 음료수 3종류가 있는데. 이걸 3명의 학생에게 종류 상관없이 1개씩 나누어주려고 한다.

첫번째로 선택하는 학생은 총 7개 중 하나를 고를 수 있다. 두번째 학생은 첫번째 학생이 가져가고 남은 6개 중 하나를, 세번째 학생은 남은 5개 중 하나를 가져가게 될 것이다. 이렇게 모든 학생이 차례로 과자와 음료수를 선택하는 방법은 `7 * 6 * 5 = 210`가지가 된다.

이를 식으로 표현하면 다음과 같다.

![순열 식](https://user-images.githubusercontent.com/62706988/106419339-9f48f800-649b-11eb-9b45-e0f33352ab69.png)

기호는 `nPr`과 같이 표기한다.

![순열 식2](https://user-images.githubusercontent.com/62706988/106419345-a40dac00-649b-11eb-83c8-0649c8583912.png)   
<br />   

**조합**

- 서로 다른 n개 중 r개를 선택하는 경우의 수
- 순서와 상관이 없으며 중복은 허용되지 않는다.

**예시**

위의 예시와 동일하게 과자 4종류와 음료수 3종류가 있을 때, 이번에는 한 학생이 3개를 가져가려고 한다.

여러 학생이 가져갈 때에는 다른 학생이 먼저 선택해버리면 그걸 가져갈 수 없었지만, 한 학생이 가져간다고 하면 어떤 종류를 먼저 선택하든 상관이 없다. 어차피 모두 그 학생이 가져가는 것이기 때문이다. 이 학생이 선택할 수 있는 조합의 수를 구하려면 일단 순열을 구하고, 순서를 고려하는 경우의 수를 빼주면 된다. 3개를 순서대로 나열하는 경우의 수는 `3 * 2 * 1 = 6 = 3!`이다.

이를 정리하면 다음과 같다.

![조합 식](https://user-images.githubusercontent.com/62706988/106420474-14b5c800-649e-11eb-88d9-fdf6fb69b37a.png)

기호는 `nCr`과 같이 표기한다.

![조합 식2](https://user-images.githubusercontent.com/62706988/106420736-9a397800-649e-11eb-9eba-eedcd1f9c706.png)   
<br />   

**구현**

- 조합

```jsx
const getCombinations = function (arr, selectNumber) {
  const results = [];
  if (selectNumber === 1) return arr.map((value) => [value]); // 1개씩 택할 때, 바로 모든 배열의 원소 return

  arr.forEach((fixed, index, origin) => {
    const rest = origin.slice(index + 1); // 해당하는 fixed를 제외한 나머지 뒤
    const combinations = getCombinations(rest, selectNumber - 1); // 나머지에 대해서 조합을 구한다.
    const attached = combinations.map((combination) => [fixed, ...combination]); //  돌아온 조합에 떼 놓은(fixed) 값 붙이기
    results.push(...attached); // 배열 spread syntax 로 모두다 push
  });

  return results; // 결과 담긴 results return
}

const example = [1,2,3,4];
const result = getCombinations(example, 3);
console.log(result);
// => [ [ 1, 2, 3 ], [ 1, 2, 4 ], [ 1, 3, 4 ], [ 2, 3, 4 ] ]
```

- 순열

```jsx
const getPermutations= function (arr, selectNumber) {
  const results = [];
  if (selectNumber === 1) return arr.map((value) => [value]); // 1개씩 택할 때, 바로 모든 배열의 원소 return

  arr.forEach((fixed, index, origin) => {
    const rest = [...origin.slice(0, index), ...origin.slice(index+1)] // 해당하는 fixed를 제외한 나머지 배열 
    const permutations = getPermutations(rest, selectNumber - 1); // 나머지에 대해 순열을 구한다.
    const attached = permutations.map((permutation) => [fixed, ...permutation]); // 돌아온 순열에 대해 떼 놓은(fixed) 값 붙이기
    results.push(...attached); // 배열 spread syntax 로 모두다 push
  });

  return results; // 결과 담긴 results return
};

const example = [1,2,3,4];
const result = getPermutations(example, 3);
console.log(result);
// => [
//   [ 1, 2, 3 ], [ 1, 2, 4 ],
//   [ 1, 3, 2 ], [ 1, 3, 4 ],
//   [ 1, 4, 2 ], [ 1, 4, 3 ],
//   [ 2, 1, 3 ], [ 2, 1, 4 ],
//   [ 2, 3, 1 ], [ 2, 3, 4 ],
//   [ 2, 4, 1 ], [ 2, 4, 3 ],
//   [ 3, 1, 2 ], [ 3, 1, 4 ],
//   [ 3, 2, 1 ], [ 3, 2, 4 ],
//   [ 3, 4, 1 ], [ 3, 4, 2 ],
//   [ 4, 1, 2 ], [ 4, 1, 3 ],
//   [ 4, 2, 1 ], [ 4, 2, 3 ],
//   [ 4, 3, 1 ], [ 4, 3, 2 ]
// ]
```
<br />

### BFS / DFS

- 그래프 자료구조에서 모든 정점을 탐색하기 위한 방법

![BFS](https://blog.kakaocdn.net/dn/c305k7/btqB5E2hI4r/ea7vFo08tkDYo4c8wkfVok/img.gif)

- BFS (Breadth-First Search)
    - 최대한 넓게 이동한 다음, 더 이상 갈 곳이 없을 때 아래로 이동한다.
    - 루트 노드에서 인접한 노드를 먼저 탐색하는 방법이다.
    - 주로 두 노드 사이의 최단 경로를 찾고 싶을 때 이 방법을 선택한다.


![DFS](https://blog.kakaocdn.net/dn/xC9Vq/btqB8n5A25K/GyOf4iwqu8euOyhwtFuyj1/img.gif)

- DFS (Depth-First Search)
    - 최대한 깊이 내려간 뒤 더 이상 갈 곳이 없을 경우 옆으로 이동한다.
    - BFS에 비해 좀 더 간단하고, 검색 속도가 느리다.
    - 모든 노드를 방문하고자 하는 경우에 이 방법을 선택한다.
- 두 방법 모두 모든 노드를 검색한다는 점에서 시간 복잡도는 동일하다.
  N은 노드, E는 간선일 때
    - 인접 행렬로 구현 : O(N^2)
    - 인접 리스트로 구현 : O(N+E)
- 일반적으로 E의 크기가 N^2에 비해 작으므로 인접 리스트 방식이 효율적이다.
<br />

## 추천 문제

- 2309번: 일곱 난쟁이
- 2231번: 분해합
- 3085번: 사탕 게임
- 10448번: 유레카 이론
- 2503번: 숫자 야구
- 1018번: 체스판 다시 칠하기
- 1182번: 부분집합의 합 ⭐️
<br />

> **참고**   
> 
> [전체적인 개념 및 예시 참고](https://hongjw1938.tistory.com/78)   
> [완전 탐색을 고려하는 경우](https://wogud6792.tistory.com/59)   
> [코어 자바스크립트 - 재귀](https://ko.javascript.info/recursion)   
> [순열과 조합 알고리즘](https://jun-choi-4928.medium.com/javascript%EB%A1%9C-%EC%88%9C%EC%97%B4%EA%B3%BC-%EC%A1%B0%ED%95%A9-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-21df4b536349)   
> [BFS / DFS](https://devuna.tistory.com/32)
> [추천 문제](https://blog.naver.com/kks227/220769870195)
