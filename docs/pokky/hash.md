# 알고리즘 문제

## **해시 테이블**

- 해시 테이블은 고정된 크기의 자료구조로 처음에 크기가 정해진다.
- 해시 테이블을 사용하면 자료를 쉽고 빠르게 저장할 수 있고 키-값 쌍을 기반으로 자료를 얻을 수 있다.
    - O(1)의 시간복잡도를 가진다
- 간단히 하면 해시 테이블은 인덱스가 해싱 함수에 의해 계산되는 배열과 유사하다. 이때 인덱스는 메모리에서 유일한 공간을 식별하기 위한 것이다
    - 유일한 공간 = 고유한 인덱스

## **해시 테이블의 요소**

### **키(key)**

- 고유한 값. 해시의 input이 된다. 문자열로 이루어 지며, 무한한 가짓수를 가지고 있다. 메모리에서 유일한 공간을 식별하기 위한 것이다.

### **값(value)**

- 저장소에 최종적으로 저장되는 값으로 키와 매칭되어 저장, 삭제, 검색, 접근이 가능해야 한다.

### **해시 함수(hash function)**

- 해시 함수는 특정 키를 자료를 저장하는 배열의 인덱스로 변환한다.

### **해시(hash)**

- 해시 함수의 결과물이며, 저장소에서 값과 매칭되어 저장된다.

![image](https://user-images.githubusercontent.com/75062526/160441571-0a5830e4-4562-4981-a70a-2785fd06de0b.png)

## **해싱 기법**

### 소수 해싱

- 모듈러 연산을 통해 인덱스를 얻어내는 방법.

### **탐사**

- 선형 탐사

동일한 키로 해싱이 되는 경우 해당 키의 다음 빈 곳을 찾아 해싱하는 방법.

선형 탐사는 충돌이 일어났다면 get(key)를 사용할 때 원래 해시 결과에서 부터 원하는 결과를 찾을 때까지 테이블을 순회하게 된다.

> ex) 만약 해싱된 키가 7인데 이미 값이 있을 경우 다음으로 빈 곳이 8이라면 8로 해싱된다. 만약 8이 아니라 16이 다음 빈 곳이 었다면 get(key)사용 시 원래 결과인 7부터 16까지 테이블을 순회한다.
> 
- 이차 탐사

이차 탐사는 매번 1씩 증가시키는 것이 아니라 완전 제곱을 사용하는 방법이다. 사용 가능한 인덱스에 키를 균등하게 분배하는 데 도움이 된다.

### **재해싱/이중 해싱**

- 재해싱은 원래 해싱 함수로부터 나온 결과를 한 번 더 해싱하는 것이다. 이때 사용되는 이차 해싱 함수가 가져야 할 요구 사항이 존재한다.

## **해시 충돌(hash collision)**

- 문자열 형태라 무한한 키에 비해 생성 처음부터 고정된 값을 가지는 유한한 해시 때문에 키가 유일하지 않은 것을 말한다.

![image](https://user-images.githubusercontent.com/75062526/160441469-7a29f998-4740-4014-96a3-b756d147835f.png)

최악 시간복잡도 → O(n)